---
title: IO模式探究
date: 2018-10-07 16:22:17
tags:  io
categories: java基础
---

### IO模式探究
 
 ----------
 一、五种I/O模型 <br>
&nbsp;&nbsp;为什么IO操作要发起系统调用？          
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程无法直接获取硬盘的数据，硬盘的数据只能通过内核获取。所谓的系统调用即是进程通知内核说我要磁盘中的数据，你帮我把数据读写了。   

>IO具体过程如下：   
&nbsp;&nbsp;&nbsp;&nbsp;    ①进程向内核发起一个系统调用，   
&nbsp;&nbsp;&nbsp;&nbsp; ②内核接收到系统调用，知道是对文件的请求，于是告诉磁盘，把文件读取出来     
&nbsp;&nbsp;&nbsp;&nbsp;    ③磁盘接收到来着内核的命令后，把文件载入到内核的内存空间里面           
&nbsp;&nbsp;&nbsp;&nbsp; ④内核的内存空间接收到数据之后，把数据copy到用户进程的内存空间(此过程是I/O发生的地方)                
&nbsp;&nbsp;&nbsp;&nbsp;  ⑤进程内存空间得到数据后，给内核发送通知           
 &nbsp;&nbsp;&nbsp;&nbsp; ⑥内核把接收到的通知回复给进程，此过程为唤醒进程，然后进程得到数据，进行下一步操作
![image](http://blog.51cto.com/attachment/201309/205126317.png)         


#### 一、 IO五模型         
 1.  阻塞I/0   <br>
  当进程调用阻塞型IO时，进程必须等待系统完成所有调用才能进行自己的工作。在系统进行调用期间，进程只能让出cpu时间片，处于睡眠状态，直到系统通知进程唤醒。
其图解如下：
![阻塞I/O的图解](http://blog.51cto.com/attachment/201309/205500239.png)      
 2.  非阻塞I/O <br>
 系统知道自己需要一定时间完成IO操作，所以就让进程发起调用后，先去做自己的事情，而不是阻塞等待。进程每隔一段时间后需要询问系统调用是否完成，如果未完成，系统会立即返回错误，如EWOULDBLOCK，直至系统调用完成，进程获取数据（忙等待）
![非阻塞I/O的图解](http://blog.51cto.com/attachment/201309/205605819.png)
 3. I/O复用  <br>
   I/O复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个或多个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后，进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。
![I/O复用的图解](http://ossi4.51cto.com/attachment/201309/205635176.png) 
 4. 事件(信号)驱动I/O  <br>
 (1)水平触发的事件驱动机制；内核通知进程来读取数据，进程没来读取数据，内核需要一次一次的通知进程；<br>
(2)边缘触发的事件驱动机制；内核只通知一次让进程来读取数据，进程可以在超时时间之内随时来读取数据。
![事件(信号)驱动I/O的图解](http://blog.51cto.com/attachment/201309/210003879.png)
 5. 异步I/O  <br>
 当现线程遇到IO操作时，线程不去处理IO而是交由工作线程处理，不会处于阻塞状态，转而继续处理自己的事情，当IO操作完成后，工作线程会通知当前线程，由当前线程做出相应处理。
![image](http://blog.51cto.com/attachment/201309/210054915.png)

二、同步与异步，阻塞与非阻塞

同步阻塞IO： 
设备IO忙时，内核对发起IO请求的进程说：“现在设备忙，你别走开，在这里等吧，你看IO什么时候做完，做完了你把数据拿走就是了” 
发起IO请求的进程说：“好，那我在这等你” 

同步非阻塞IO： 
设备IO忙时，内核对发起IO请求的进程说：“我已经知道你要IO了，但设备现在有点忙，你回家吧，我会记住你这个事的，我有记录呢，只要设备一空闲我就给你做IO的，做完了给你打电话让你过来拿数据” 
发起IO请求的进程说：“IO还没做完呢，我不走，我要不断的问我的IO什么时候完成，知道你把我的IO做完为止” 

异步阻塞IO： 
设备IO忙时，内核对发起IO请求的进程说：“现在设备忙，你别走开，在这里等吧，你看IO什么时候做完，做完了你把数据拿走就是了” 
发起IO请求的进程说：“哦，您忙吧，我在这里排队等着呢，不过我排队时也无聊，就做做其他的事情吧，我会时不时就看看我的IO做完没有的” 

异步非阻塞IO： 
设备IO忙时，内核对发起IO请求的进程说：“我已经知道你要IO了，但设备现在有点忙，你回家吧，我会记住你这个事的，我有记录呢，只要设备一空闲我就给你做IO的，做完了给你打电话让你过来拿数据” 
发起IO请求的进程说：“好吧，您看我事也挺多的，既然现在IO一时半会也完成不了，那我先回家去做做其他的事吧，谢谢啊” 


总结： 
阻塞/非阻塞是内核级的，同步/异步是进程级的，同步非阻塞和异步阻塞一般不会采用，异步非阻塞一般效率比较高，他能够把cpu和io并行处理，当然，如果没有cpu和io并行的这种情况，那就用同步阻塞比较好，这样编程比较简单，且不用多次在内核空间和用户空间进行切换









[1] [Partially Reproduced](http://blog.51cto.com/litaotao/1289790)
 


